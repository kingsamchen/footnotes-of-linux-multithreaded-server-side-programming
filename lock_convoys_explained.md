# Lock Convoys Explained

-- by 潘爱民，2010-10-9

    Lock Convoys 是在多线程并发环境下由于锁的使用而引起的性能退化问题。当多个相同优先级的线程频繁地争抢同一个锁时可能会引起 lock convoys 问题，一般而言，lock convoys 并不会像 deadlock 或 livelock 那样造成应用逻辑停止不前，相反地，遭受 lock convoys 的系统或应用程序仍然往前运行，但是，由于线程们频繁地争抢锁而导致过多的线程环境切换，从而使得系统的运行效率大为降低，而且，若存在同等优先级下不参与锁争抢的线程，则它们可以获得相对较多的处理器资源，从而造成系统调度的不公平性。

本文将解释 lock convoys 问题的缘由。

    假设一组线程在频繁地获取锁（所谓频繁，指在一个时间片的执行周期内多次获取锁），比如在 Windows 应用程序中常常用临界区（critical section）来保护一个共享变量或者防止一段代码被重入，这是极有可能发生的。假设线程 A 获取到了锁，这时发生了线程调度中断，它的时间片用完了，于是，系统调度器交给下一个线程执行，不妨设线程 B 获得了执行权。由于此锁被线程 A 获取，所以，当线程 B 执行到获取锁的操作时，虽然时间片未用完，但不得不放弃执行权。如此继续，所有同等优先级且要竞争此锁的线程都被阻塞。调度器再次回到线程 A，很快地线程 A 释放了锁。在操作系统中，释放一个锁，意味着内核中如果有线程正在等待该锁，则它的状态就可以变成运行态。比如，线程 B 的获取操作成功。但此时，内核只是将线程 B 标记为锁的所有者，而线程 A 继续执行。很快地，线程 A 又要获取锁了，由于该锁已经被标记给线程 B 了，所以线程 A 不得不放弃时间片，将控制权交给调度器。调度器终于可以捡起线程 B，将处理器的执行权交给它。等到线程 B 释放了锁，下一个线程获得锁的所有权，并且等到线程 B 放弃执行权或者结束时间片之后就有机会被执行。此过程一直持续，经过一轮之后又会回到线程 A，从而继续下一轮的争抢。在此期间，这些线程总是未执行满时间片就不得不放弃执行权。下面的图说明了三个线程在争抢一个锁时候的执行情况。

![][img-0]

    假设一个线程在一个满时间片的执行过程中要多次获取 / 释放锁，它一旦释放了锁，则意味着，只要存在锁竞争，它在分配给它的当前时间片内已经无法再重新获得锁了。所以，它只能执行到它的下一次获取操作为止。譬如，参与竞争的线程平均执行 1/3 时间片就要获取锁，那么，线程的实际执行时间变成了 1/3 时间片。系统的调度粒度变成原来的 1/3 时间间隔。这引起了 3 倍数量的线程切换。从上图的右半部分可以看出，每个线程在一轮的循环中，只有 1/3 时间片的机会。这导致了 3 倍的线程切换。

    除了引起调度粒度变小以外，lock convoys 的另一个问题是造成调度器的时间分配不公平。假设另有一个线程 X 也是在同等的优先级上运行，但没有参与锁竞争。于是，在每一轮的锁竞争过程中，线程 X 都有机会被分配一次完整的时间片，于是，这些竞争的线程在一轮中获得 1/3 时间片，而非竞争的线程可以获得完整的时间片。当然，你可以说这种不公平是由于它们抢锁而引起的，但从时间分配比例而言，参与竞争与不参与竞争的线程是不公平的。下图说明了线程 X 和 A、B、C 之间的执行时间差异。

![][img-1]

    由以上描述可以看出，Lock convoys 的存在条件是，参与竞争的线程频繁地获取锁，锁被一个线程释放以后其所有权便落到了另一个线程的手里。在操作系统中，相同优先级的线程按照 FIFO 的顺序被调度和执行，竞争同一个锁的线程也按照 FIFO 的顺序被依次成功地获取到锁。这些条件在现代操作系统中都能被满足，包括 Windows。

    Lock convoys 虽然不是致命的问题，但也可能在实际系统中发生。Sue Loh 在她的博客文章 [1] 中展示了在 Windows CE 中发生的 lock convoy 问题。她也讨论了一种合理的缓解 lock convoy 的方案，要求在每个线程获取锁的时候先尝试（try），如果尝试多次仍不成功，再阻塞。

注 1：关于 lock convoys 的介绍资料非常少，在 wikipedia 上也只有极有限的说明 [2]，Sue Loh 的博客文章 [1] 有比较详细的说明。我计划在下一篇文章中再讨论 lock convoys 问题在 Windows 平台上的表现（以 Windows Server 2003 SP1 和 WRK 作为参照）以及线程执行路径。

注 2：关于 lock convoys 的中文翻译，我看到有一本书上将其翻译为 “锁护送”。个人感觉不是非常妥当，或许翻译为“锁封护” 或“锁护封”好一些。

References:

[1] Sue Loh, Lock Convoys and How to Recognize Them, [http://blogs.msdn.com/b/sloh/archive/2005/05/27/lock-convoys-and-how-to-recognize-them.aspx](http://blogs.msdn.com/b/sloh/archive/2005/05/27/lock-convoys-and-how-to-recognize-them.aspx), 2005.

[2] Lock Convoys, [http://en.wikipedia.org/wiki/Lock_convoy](http://en.wikipedia.org/wiki/Lock_convoy)

[img-0]:/img/lock_convoys_1.gif

[img-1]:/img/lock_convoys_2.gif

---
1. 见书 P40
2. 原文链接：https://blog.csdn.net/panaimin/article/details/5981766